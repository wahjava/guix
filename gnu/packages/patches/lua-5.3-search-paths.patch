Add support for GUIX_LUA_PATH and GUIX_LUA_CPATH, which don't use the usual
Lua '?' path wildcard, and thus are compatible with Guix's search-paths
mechanism.

--- a/src/loadlib.c
+++ b/src/loadlib.c
@@ -268,6 +268,14 @@
 #define LUA_CPATH_VAR   "LUA_CPATH"
 #endif
 
+#if !defined(GUIX_LUA_PATH_VAR)
+#define GUIX_LUA_PATH_VAR    "GUIX_LUA_PATH"
+#endif
+
+#if !defined(GUIX_LUA_CPATH_VAR)
+#define GUIX_LUA_CPATH_VAR   "GUIX_LUA_CPATH"
+#endif
+
 
 #define AUXMARK         "\1"	/* auxiliary mark */
 
@@ -455,6 +463,37 @@
 }
 
 
+static const char *guix_searchpath (lua_State *L, const char *name,
+                                                  const char *path,
+                                                  const char *sep,
+                                                  const char *dirsep,
+                                                  const char *suffix) {
+  luaL_Buffer msg;  /* to build error message */
+  luaL_buffinit(L, &msg);
+  if (*sep != '\0')  /* non-empty separator? */
+    name = luaL_gsub(L, name, sep, dirsep);  /* replace it by 'dirsep' */
+  while ((path = pushnexttemplate(L, path)) != NULL) {
+    /* add name to the end of the path */
+    luaL_Buffer buffer;
+    luaL_buffinit(L, &buffer);
+    luaL_addstring(&buffer, lua_tostring(L, -1));
+    luaL_addstring(&buffer, dirsep);
+    luaL_addstring(&buffer, name);
+    luaL_addstring(&buffer, suffix);
+    luaL_addchar(&buffer, '\0');
+    luaL_pushresult(&buffer);
+    const char *filename = lua_tostring(L, -1);
+    if (readable(filename))  /* does file exist and is readable? */
+      return filename;  /* return that file name */
+    lua_pushfstring(L, "\n\tno file '%s'", filename);
+    lua_remove(L, -2);  /* remove file name */
+    luaL_addvalue(&msg);  /* concatenate error msg. entry */
+  }
+  luaL_pushresult(&msg);  /* create error message */
+  return NULL;  /* not found */
+}
+
+
 static int ll_searchpath (lua_State *L) {
   const char *f = searchpath(L, luaL_checkstring(L, 1),
                                 luaL_checkstring(L, 2),
@@ -471,13 +510,23 @@
 
 static const char *findfile (lua_State *L, const char *name,
                                            const char *pname,
+                                           const char *guix_pname,
+                                           const char *guix_suffix,
                                            const char *dirsep) {
   const char *path;
   lua_getfield(L, lua_upvalueindex(1), pname);
   path = lua_tostring(L, -1);
   if (path == NULL)
     luaL_error(L, "'package.%s' must be a string", pname);
-  return searchpath(L, name, path, ".", dirsep);
+  const char *filename = searchpath(L, name, path, ".", dirsep);
+  if (filename != NULL) return filename;
+
+  const char *guix_path;
+  lua_getfield(L, lua_upvalueindex(1), guix_pname);
+  guix_path = lua_tostring(L, -1);
+  if (guix_path == NULL)
+    luaL_error(L, "'package.%s' must be a string", guix_pname);
+  return guix_searchpath(L, name, guix_path, ".", dirsep, guix_suffix);
 }
 
 
@@ -495,7 +544,7 @@
 static int searcher_Lua (lua_State *L) {
   const char *filename;
   const char *name = luaL_checkstring(L, 1);
-  filename = findfile(L, name, "path", LUA_LSUBSEP);
+  filename = findfile(L, name, "path", "guix_path", ".lua", LUA_LSUBSEP);
   if (filename == NULL) return 1;  /* module not found in this path */
   return checkload(L, (luaL_loadfile(L, filename) == LUA_OK), filename);
 }
@@ -529,7 +578,7 @@
 
 static int searcher_C (lua_State *L) {
   const char *name = luaL_checkstring(L, 1);
-  const char *filename = findfile(L, name, "cpath", LUA_CSUBSEP);
+  const char *filename = findfile(L, name, "cpath", "guix_cpath", ".so", LUA_CSUBSEP);
   if (filename == NULL) return 1;  /* module not found in this path */
   return checkload(L, (loadfunc(L, filename, name) == 0), filename);
 }
@@ -542,7 +591,7 @@
   int stat;
   if (p == NULL) return 0;  /* is root */
   lua_pushlstring(L, name, p - name);
-  filename = findfile(L, lua_tostring(L, -1), "cpath", LUA_CSUBSEP);
+  filename = findfile(L, lua_tostring(L, -1), "cpath", "guix_cpath", ".so", LUA_CSUBSEP);
   if (filename == NULL) return 1;  /* root not found */
   if ((stat = loadfunc(L, filename, name)) != 0) {
     if (stat != ERRFUNC)
@@ -713,6 +762,8 @@
 #endif
   /* placeholders */
   {"preload", NULL},
+  {"guix_cpath", NULL},
+  {"guix_path", NULL},
   {"cpath", NULL},
   {"path", NULL},
   {"searchers", NULL},
@@ -771,6 +822,8 @@
   /* set paths */
   setpath(L, "path", LUA_PATH_VAR, LUA_PATH_DEFAULT);
   setpath(L, "cpath", LUA_CPATH_VAR, LUA_CPATH_DEFAULT);
+  setpath(L, "guix_path", GUIX_LUA_PATH_VAR, GUIX_LUA_PATH_DEFAULT);
+  setpath(L, "guix_cpath", GUIX_LUA_CPATH_VAR, GUIX_LUA_CPATH_DEFAULT);
   /* store config information */
   lua_pushliteral(L, LUA_DIRSEP "\n" LUA_PATH_SEP "\n" LUA_PATH_MARK "\n"
                      LUA_EXEC_DIR "\n" LUA_IGMARK "\n");

--- a/src/luaconf.h
+++ b/src/luaconf.h
@@ -211,6 +211,11 @@
 		LUA_CDIR"?.so;" LUA_CDIR"loadall.so;" "./?.so"
 #endif			/* } */
 
+/* The GUIX variant paths default to empty, so they do nothing unless
+** asked. */
+#define GUIX_LUA_PATH_DEFAULT  ""
+#define GUIX_LUA_CPATH_DEFAULT ""
+
 
 /*
 @@ LUA_DIRSEP is the directory separator (for submodules).